import * as fs from "fs";
import { extractShaderProgramFromGlsl } from "./convertGlslIntoShaderProgram.js";
import { ConnectionPointType } from "../../connection/connectionPointType.js";
import { BlockDisableStrategy } from "../../blockFoundation/disableableShaderBlock.js";

const EXTRA_IMPORTS = "@EXTRA_IMPORTS@";
const SHADER_PROGRAM = "@SHADER_PROGRAM@";
const BLOCK_NAME = "@BLOCK_NAME@";
const NAMESPACE = "@NAMESPACE@";
const SHADER_BINDING_PRIVATE_VARIABLES = "@SHADER_BINDING_PRIVATE_VARIABLES@";
const CAMEL_CASE_UNIFORM = "@CAMEL_CASE_UNIFORM@";
const CONNECTION_POINT_TYPE = "@CONNECTION_POINT_TYPE@";
const CONNECTION_POINT_DEFAULT_VALUE = "@CONNECTION_POINT_DEFAULT_VALUE@";
const SHADER_BINDING_EXTENDS = "@SHADER_BINDING_EXTENDS@";
const SHADER_BINDING_CTOR_DOCSTRING_PARAMS = "@SHADER_BINDING_CTOR_DOCSTRING_PARAMS@";
const SHADER_BINDING_CTOR_PARAMS = "@SHADER_CTOR_PARAMS@";
const SHADER_BINDING_SUPER_PARAMS = "@SHADER_BINDING_SUPER_PARAMS@";
const SHADER_BINDING_CTOR = "@SHADER_BINDING_CTOR@";
const SHADER_BINDING_BIND = "@SHADER_BINDING_BIND@";
const SHADER_BLOCK_EXTENDS = "@SHADER_BLOCK_EXTENDS@";
const BLOCK_INPUT_PROPERTIES = "@BLOCK_INPUT_PROPERTIES@";
const BLOCK_DISABLE_OPTIMIZATION = "@BLOCK_DISABLE_OPTIMIZATION@";
const BLOCK_DISABLE_STRATEGY = "@BLOCK_DISABLE_STRATEGY@";
const BLOCK_GET_SHADER_BINDING_VARS = "@BLOCK_SHADER_BINDING_BIND_VARS@";
const BLOCK_GET_SHADER_PARAM_LIST = "@BLOCK_GET_SHADER_PARAM_LIST@";
const EFFECT_SETTER = "@EFFECT_SETTER@";

const ShaderBindingPrivateVariablesTemplate = `    private readonly _${CAMEL_CASE_UNIFORM}: RuntimeData<ConnectionPointType.${CONNECTION_POINT_TYPE}>;`;
const ShaderBindingCtorDocstringParams = `     * @param ${CAMEL_CASE_UNIFORM} - The ${CAMEL_CASE_UNIFORM} runtime value`;
const ShaderBindingCtorParams = `        ${CAMEL_CASE_UNIFORM}: RuntimeData<ConnectionPointType.${CONNECTION_POINT_TYPE}>`;
const ShaderBindingCtor = `        this._${CAMEL_CASE_UNIFORM} = ${CAMEL_CASE_UNIFORM};`;
const ShaderBindingBind = `        effect.${EFFECT_SETTER}(this.getRemappedName(uniforms.${CAMEL_CASE_UNIFORM}), this._${CAMEL_CASE_UNIFORM}.value);`;

const BlockInputProperty = `    /**
     * The ${CAMEL_CASE_UNIFORM} connection point.
     */
    public readonly ${CAMEL_CASE_UNIFORM} = this._registerInput(uniforms.${CAMEL_CASE_UNIFORM}, ConnectionPointType.${CONNECTION_POINT_TYPE});
`;
const BlockInputOptionalProperty = `    /**
    /**
     * The ${CAMEL_CASE_UNIFORM} connection point.
     */
    public readonly ${CAMEL_CASE_UNIFORM} = this._registerOptionalInput(
        "${CAMEL_CASE_UNIFORM}",
        ConnectionPointType.${CONNECTION_POINT_TYPE},
        createStrongRef(${CONNECTION_POINT_DEFAULT_VALUE})
    );
`;
const BlockGetShaderBindingVars = `        const ${CAMEL_CASE_UNIFORM} = this._confirmRuntimeDataSupplied(this.${CAMEL_CASE_UNIFORM});`;

const FileTemplate = `/* eslint-disable prettier/prettier */
// ************************************************************
// Note: this file is auto-generated, do not modify it directly
// ************************************************************

// It was generated by convertGlslIntoBlock() from
// an annotated .glsl file. Modify the .glsl file to make changes
// to the block. This file will get overwritten when the build
// is run or during a watch when the .glsl file is updated.

import type { Effect } from "@babylonjs/core/Materials/effect";

import {
    ${SHADER_BINDING_EXTENDS},
    type RuntimeData,
    ConnectionPointType,
    type SmartFilter,
    ${SHADER_BLOCK_EXTENDS},
    type ShaderProgram,
${EXTRA_IMPORTS}} from "@babylonjs/smart-filters";${SHADER_PROGRAM}
/**
 * The shader binding for the ${BLOCK_NAME}, used by the runtime
 */
class ${BLOCK_NAME}ShaderBinding extends ${SHADER_BINDING_EXTENDS} {
${SHADER_BINDING_PRIVATE_VARIABLES}

    /**
     * Creates a new shader binding instance for the block.
${SHADER_BINDING_CTOR_DOCSTRING_PARAMS}
     */
    constructor(
${SHADER_BINDING_CTOR_PARAMS}
    ) {
        super(${SHADER_BINDING_SUPER_PARAMS});
${SHADER_BINDING_CTOR}
    }

    /**
     * Binds all the required data to the shader when rendering.
     * @param effect - defines the effect to bind the data to
     */
    public override bind(effect: Effect): void {
${SHADER_BINDING_BIND}
    }
}

/**
 * The implementation of the ${BLOCK_NAME}
 */
export class ${BLOCK_NAME} extends ${SHADER_BLOCK_EXTENDS} {
    /**
     * The class name of the block.
     */
    public static override ClassName = "${BLOCK_NAME}";

    /**
     * The namespace of the block.
     */
    public static override Namespace = "${NAMESPACE}";

${BLOCK_INPUT_PROPERTIES}
    /**
     * The shader program (vertex and fragment code) to use to render the block
     */
    public static override ShaderCode = shaderProgram;

    /**
     * Instantiates a new ${BLOCK_NAME}.
     * @param smartFilter - The smart filter this block belongs to
     * @param name - The friendly name of the block
     */
    constructor(smartFilter: SmartFilter, name: string) {
        super(smartFilter, name, ${BLOCK_DISABLE_OPTIMIZATION}${BLOCK_DISABLE_STRATEGY});
    }

    /**
     * Get the class instance that binds all the required data to the shader (effect) when rendering.
     * @returns The class instance that binds the data to the effect
     */
    public getShaderBinding(): ${SHADER_BINDING_EXTENDS} {
${BLOCK_GET_SHADER_BINDING_VARS}

        return new ${BLOCK_NAME}ShaderBinding(${BLOCK_GET_SHADER_PARAM_LIST});
    }
}

`;

/**
 * Converts a single shader to a .ts file which exports a Smart Filter block
 * @param fragmentShaderPath - The path to the fragment file for the shader
 * @param importPath - The path to import the ShaderProgram type from
 */
export function convertGlslIntoBlock(fragmentShaderPath: string, importPath: string): void {
    const extraImports: string[] = [];

    const { shaderProgramCode, fragmentShaderInfo } = extractShaderProgramFromGlsl(
        fragmentShaderPath,
        importPath,
        false,
        false
    );

    // Validation
    if (!fragmentShaderInfo.blockType) {
        throw new Error("The glsl file must contain a header comment with a smartFilterBlockType value");
    }

    // Generate shader binding private variables
    const shaderBindingPrivateVariables = fragmentShaderInfo.uniforms.map((uniform) => {
        return ShaderBindingPrivateVariablesTemplate.replace(CAMEL_CASE_UNIFORM, uniform.name).replace(
            CONNECTION_POINT_TYPE,
            getConnectionPointTypeString(uniform.type)
        );
    });

    // Generate the shader binding constructor docstring params
    const shaderBindingCtorDocstringParams = fragmentShaderInfo.uniforms.map((uniform) => {
        return ShaderBindingCtorDocstringParams.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name);
    });

    // Generate the shader binding constructor params
    const shaderBindingCtorParams = fragmentShaderInfo.uniforms.map((uniform) => {
        return ShaderBindingCtorParams.replace(CAMEL_CASE_UNIFORM, uniform.name).replace(
            CONNECTION_POINT_TYPE,
            getConnectionPointTypeString(uniform.type)
        );
    });

    // Generate the shader binding constructor
    const shaderBindingCtor = fragmentShaderInfo.uniforms.map((uniform) => {
        return ShaderBindingCtor.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name);
    });

    // Generate the shader binding bind
    const shaderBindingBind = fragmentShaderInfo.uniforms.map((uniform) => {
        return ShaderBindingBind.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name).replace(
            EFFECT_SETTER,
            getEffectSetter(uniform.type)
        );
    });

    // Generate the block input properties
    const blockInputProperties = fragmentShaderInfo.uniforms.map((uniform) => {
        if (uniform.properties?.default !== undefined) {
            if (extraImports.indexOf("    createStrongRef") === -1) {
                extraImports.push("    createStrongRef");
            }
            return BlockInputOptionalProperty.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name)
                .replace(CONNECTION_POINT_TYPE, getConnectionPointTypeString(uniform.type))
                .replace(CONNECTION_POINT_DEFAULT_VALUE, uniform.properties.default);
        } else {
            return BlockInputProperty.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name).replace(
                CONNECTION_POINT_TYPE,
                getConnectionPointTypeString(uniform.type)
            );
        }
    });

    // Generate the block get shader binding vars
    const blockGetShaderBindingVars = fragmentShaderInfo.uniforms.map((uniform) => {
        return BlockGetShaderBindingVars.replace(new RegExp(CAMEL_CASE_UNIFORM, "g"), uniform.name);
    });

    // Handle the disable optimization flag
    const disableOptimization = fragmentShaderInfo.disableOptimization === true ? "true" : "false";

    // Generate the block get shader param list
    const blockGetShaderParamList = fragmentShaderInfo.uniforms.map((uniform) => {
        return uniform.name;
    });

    // Decide if this is a disableable block or not
    let shaderBlockExtends = "ShaderBlock";
    let shaderBindingExtends = "ShaderBinding";
    let blockDisableStrategy = "";
    let shaderBindingSuperParams = "";
    if (fragmentShaderInfo.blockDisableStrategy) {
        shaderBlockExtends = "DisableableShaderBlock";
        shaderBindingExtends = "DisableableShaderBinding";
        blockDisableStrategy = `, BlockDisableStrategy.${BlockDisableStrategy[fragmentShaderInfo.blockDisableStrategy]}`;
        shaderBindingSuperParams = "parentBlock";

        shaderBindingCtorDocstringParams.unshift("     * @param parentBlock - IDisableableBlock");
        shaderBindingCtorParams.unshift("        parentBlock: IDisableableBlock");
        blockGetShaderParamList.unshift("this");

        extraImports.push("    type IDisableableBlock");
        extraImports.push("    BlockDisableStrategy");

        shaderBindingBind.unshift("        super.bind(effect);");
    }

    // Additional validation
    if (
        fragmentShaderInfo.blockDisableStrategy !== undefined &&
        fragmentShaderInfo.blockDisableStrategy !== BlockDisableStrategy.Manual
    ) {
        if (fragmentShaderInfo.uniforms.findIndex((uniform) => uniform.name === "disabled") !== -1) {
            throw new Error(
                "A block that uses a BlockDisableStrategy other than Manual should not declare its own 'disabled' uniform"
            );
        }
    }

    // Generate final contents
    const finalContents = FileTemplate.replace(SHADER_PROGRAM, shaderProgramCode)
        .replace(EXTRA_IMPORTS, extraImports.join(",\n"))
        .replace(new RegExp(BLOCK_NAME, "g"), fragmentShaderInfo.blockType)
        .replace(NAMESPACE, fragmentShaderInfo.namespace || "Other")
        .replace(new RegExp(SHADER_BINDING_EXTENDS, "g"), shaderBindingExtends)
        .replace(SHADER_BINDING_PRIVATE_VARIABLES, shaderBindingPrivateVariables.join("\n"))
        .replace(SHADER_BINDING_CTOR_DOCSTRING_PARAMS, shaderBindingCtorDocstringParams.join("\n"))
        .replace(SHADER_BINDING_CTOR_PARAMS, shaderBindingCtorParams.join(",\n"))
        .replace(SHADER_BINDING_CTOR, shaderBindingCtor.join("\n"))
        .replace(SHADER_BINDING_SUPER_PARAMS, shaderBindingSuperParams)
        .replace(SHADER_BINDING_BIND, shaderBindingBind.join("\n"))
        .replace(new RegExp(SHADER_BLOCK_EXTENDS, "g"), shaderBlockExtends)
        .replace(BLOCK_INPUT_PROPERTIES, blockInputProperties.join("\n"))
        .replace(BLOCK_DISABLE_OPTIMIZATION, disableOptimization)
        .replace(BLOCK_DISABLE_STRATEGY, blockDisableStrategy)
        .replace(BLOCK_GET_SHADER_BINDING_VARS, blockGetShaderBindingVars.join("\n"))
        .replace(BLOCK_GET_SHADER_PARAM_LIST, blockGetShaderParamList.join(","));

    // Write the block class TS file
    const outputFullPathAndFileName = fragmentShaderPath.replace(".glsl", ".ts");
    fs.writeFileSync(outputFullPathAndFileName, finalContents);
}

/**
 * Get the string representation of a connection point type
 * @param type - The connection point type
 * @returns - The string representation of the connection point type
 */
function getConnectionPointTypeString(type: ConnectionPointType): string {
    switch (type) {
        case ConnectionPointType.Float:
            return "Float";
        case ConnectionPointType.Texture:
            return "Texture";
        case ConnectionPointType.Color3:
            return "Color3";
        case ConnectionPointType.Color4:
            return "Color4";
        case ConnectionPointType.Vector2:
            return "Vector2";
        case ConnectionPointType.Boolean:
            return "Boolean";
    }
}

/**
 * Get the effect setter for a connection point type
 * @param type - The connection point type
 * @returns - The effect setter for the connection point type
 */
function getEffectSetter(type: ConnectionPointType): string {
    switch (type) {
        case ConnectionPointType.Float:
            return "setFloat";
        case ConnectionPointType.Texture:
            return "setTexture";
        case ConnectionPointType.Color3:
            return "setColor3";
        case ConnectionPointType.Color4:
            return "setDirectColor4";
        case ConnectionPointType.Vector2:
            return "setVector2";
        case ConnectionPointType.Boolean:
            return "setBool";
    }
}
